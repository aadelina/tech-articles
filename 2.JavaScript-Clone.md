# 深入浅出：JavaScript浅拷贝与深拷贝 

## 1.前言
假如你有一本宝藏秘籍书，并且书中囊括对其引用的全部文献书籍，在书中的附件位置。有朋友来找你借书，为了保护书籍，换了一个书名就直接借给了朋友（引用类型赋值）。后来朋友在书中写写画画，对你这本宝藏秘籍书产生了影响。再下次其他朋友来借书，你准备复印一份书中的全部知识，除了没复印书中引用的更深层的文献，如果全部复印完消耗太多时间和精力，直接将附件文献借给朋友了（浅拷贝）。有个朋友精读书籍，读到了更深层次的附件，结果对附件写写画画。最后你忍无可忍，将书籍和附件文献全部复印了出来，以供朋友们解读，从此自己的宝藏秘籍书不再受影响（深拷贝）。

## 2.详解
- 引用类型赋值：直接将对象赋值到一个新的变量
- 浅拷贝：创建一个新的对象，**只拷贝一层属性数据**到新的对象上，原对象中存在引用类型，会与原对象中的引用类型共享内存地址
![浅拷贝图片](./assets/images/clone-shallowly.png)
- 深拷贝：创建一个新的对象，**无限层拷贝属性数据**到新的对象上，新对象是一个完全独立的对象
![深拷贝图片](./assets/images/clone-deeply.png)
## 3.适用场景
浅拷贝和深拷贝都复制了值和地址，都是为了解决引用类型赋值后互相影响的问题
```
const obj = {a: 1,b:2}
const newObj = obj
newObj.a = 3
console.log(newObj,obj) //{a: 3,b:2} {a: 3,b:2} 
```
### 3.1.浅拷贝

    浅拷贝后的对象与原始对象独立，与原始对象中的引用类型共享内存地址，一经修改会影响原始数据

    1. 性能优先的简单数据结构

        当对象或数组的层级较浅，且不包含嵌套的引用类型时，浅拷贝可以快速复制数据。例如，简单的配置对象或一维数组。

    2. 只需要修改顶层属性

        如果只需要修改对象或数组的顶层属性，而不涉及嵌套结构，浅拷贝是足够的。

    3. 引用共享的场景

        当需要保留嵌套对象的引用关系时，浅拷贝是合适的。例如，多个组件共享同一个嵌套对象的引用以同步状态。

### 3.2.深拷贝

    深拷贝后的对象与原始对象完全独立，修改拷贝不会影响原始数据

    1. 嵌套对象或数组的独立操作

        当对象或数组包含多层嵌套结构时，深拷贝可以确保每一层级的内容都被独立复制，避免修改克隆对象时影响原始对象。

    2. 避免共享引用的副作用

        在需要完全独立的数据副本时，深拷贝是必要的。

    3. 处理复杂数据结构

        当需要操作复杂的嵌套数据结构（如树、图等）时，深拷贝可以避免引用关系导致的意外修改。

    4. 数据备份

        在需要保存数据的快照或备份时，深拷贝可以确保备份数据与原始数据完全独立，防止后续修改影响备份。

    5. 防止原始数据污染

        在函数中操作传入的对象或数组时，深拷贝可以避免对原始数据的污染。
## 4.优缺点
### 4.1.浅拷贝
浅拷贝的优点是性能较高，但需要注意其局限性：嵌套对象的修改会影响原始对象
### 4.2.深拷贝
深拷贝的优点是可以完全独立地操作数据，但需要注意性能开销，尤其是在处理大规模嵌套数据时。
## 5.代码实现
### 5.1.实现浅拷贝
1. 支持对象和数组两种类型
对进行浅克隆的值，只能是对象和数组，需要进行数据类型判断

2. 对数组类型的数据进行处理

- 扩展符号...
```
    const res = [...arr]
```
- slice方法
```
    const res = arr.slice()
```
- concat方法
```
    const res = arr.concat()
```
- for...of遍历
```
    const res = []

    for(const value of arr){
        res.push(value)
    }
```

3. 对对象类型的数据进行处理
- 扩展符号...
```
    const res = [...obj]
```
- Object.assign
```
    const res = Object.assign({},obj)
```
- for...of遍历

```
    const res = {}

    for(const [key,value] of Object.entries(obj)){
        res[key] = value
    }
```
4. 代码方法实现
```
//使用扩展运算符
const cloneShallowly = (o) => {
    //数据类型判断
    if(!(o instanceof Object)) return 

    if(Array.isArray(o)){
        return [...o]
    } else {
        return {...o}
    }
}

```

```
//使用各自的方法
const cloneShallowly = (o) => {
    //数据类型判断
    if(!(o instanceof Object)) return 

    if(Array.isArray(o)){
        return o.slice()
    } else {
        return Object.assign({},o)
    }
}

```

```
//使用for...of方法
const cloneShallowly = (o) => {
    //数据类型判断
    if(!(o instanceof Object)) return 

     const res = Array.isArray(o)?[]:{}

     for(const [key,value] of Object.entries(o)){
        res[key] = value
    }

    return res
    
}

```

5. 测试验证
```
const obj = {a: 1, b: {c: 2}}
const newObj = cloneShallowly(obj)
newObj.b.c = 3
//改变newObj中的 b 属性，原 obj 中的 b 属性也会被改变
console.log(newObj,obj) //{a: 1, b: {c: 3}} {a: 1, b: {c: 3}}


const arr = [1, [2, 3]] 
const newArr = cloneShallowly(arr)
newArr[1][0] = 4
//改变 newArr 中的嵌套数组的值，原 arr的嵌套数组也会发生改变
console.log(newArr,arr) //[1, [4, 3]]  [1, [4, 3]] 
```
### 5.2.实现深拷贝（简易版）

1. 一行代码实现深拷贝

适用于日常开发中深拷贝一些简单的对象
```
const obj = {a: 1, b: {c: 2}};
const newObj = JSON.parse(JSON.stringify(obj))
```
这种方式也会存在一些问题：

- 会忽略undefined、symbol和函数
```
const obj = {
  a: undefined,
  b: Symbol('b'),
  c: function () {}
}

const newObj = JSON.parse(JSON.stringify(obj))

console.log(newObj) // {} 

```

- NaN、Infinity、-Infinity 会被序列化为 null
```
const obj = {
  a: NaN,
  b: Infinity,
  c: -Infinity
}

const newObj = JSON.parse(JSON.stringify(obj))

console.log(newObj)  // {a: null,b:null, c: null}
```
- 不能解决循环引用的问题
```
const obj = {
  a: 1
}

obj.obj = obj

const newObj = JSON.parse(JSON.stringify(obj)) // 报错
```

2. 手动实现简易版深拷贝

    简易版：不考虑循环引用和特殊类型

```
const cloneDeeply = (o) => {

    if(!(o instanceof Object)) return o;

    const res = Array.isArray(o) ? [] : {}

    for(const [key,value] of Object.entries(o)){
        res[key] = cloneDeeply(value)
    }

    return res;

}
const obj = {a: 1, b: {c: 2}};
const newObj = cloneDeeply(obj)
newObj.b.c = "更改以后的";
console.log(newObj,obj); // { a: 1, b: { c: '更改以后的' } } { a: 1, b: { c: 2 } }


const arr = [1, [2, 3]] 
const newArr = cloneDeeply(arr)
newArr[1][0] = "更改以后的";
console.log(newArr,arr); // [ 1, [ '更改以后的', 3 ] ] [ 1, [ 2, 3 ] ]
```

## 6.总结

|        | 与原始数据是否指向同一地址 | 基本数据类型 | 嵌套引用类型 |
| :----- | :--: | :---------: | :---------: |
| 引用类型赋值 |  是  | 修改值影响原始数据 | 修改值影响原始数据 |
| 浅拷贝      |  否  | 修改值不影响原始数据 | 修改值影响原始数据 |
| 深拷贝      |  否  | 修改值不影响原始数据 | 修改值不影响原始数据 |

所以选择拷贝方式的时候：
- 如果对象的结构简单，浅拷贝性能更好
- 如果是复杂的嵌套对象又要求完全独立，那么使用深拷贝更安全