# 实现浅克隆 

浅克隆会创建一个新的对象，但是只会复制对象的第一层属性，如果属性是引用类型的数据，只会复制引用类型的地址

## 1.支持对象和数组两种类型
对进行浅克隆的值，只能是对象和数组，需要进行数据类型判断

## 2.对数组类型的数据进行处理

### 2.1 扩展符号...
```
    const res = [...arr]
```
### 2.2 slice方法
```
    const res = arr.slice()
```
### 2.3 concat方法
```
    const res = arr.concat()
```
### 2.4 for...of遍历
```
    const res = []

    for(const value of arr){
        res.push(value)
    }
```

## 3.对对象类型的数据进行处理
### 3.1 扩展符号...
```
    const res = [...obj]
```
### 3.2 Object.assign
```
    const res = Object.assign({},obj)
```
### 3.3 for...of遍历

```
    const res = {}

    for(const [key,value] of Object.entries(obj)){
        res[key] = value
    }
```
## 4.代码方法实现
```
//使用扩展运算符
const cloneShallowly = (o) => {
    //数据类型判断
    if(!(o instanceof Object)) return 

    if(Array.isArray(o)){
        return [...o]
    } else {
        return {...o}
    }
}

```

```
//使用各自的方法
const cloneShallowly = (o) => {
    //数据类型判断
    if(!(o instanceof Object)) return 

    if(Array.isArray(o)){
        return o.slice()
    } else {
        return Object.assign({},o)
    }
}

```

```
//使用for...of方法
const cloneShallowly = (o) => {
    //数据类型判断
    if(!(o instanceof Object)) return 

     const res = Array.isArray(o)?[]:{}

     for(const [key,value] of Object.entries(o)){
        res[key] = value
    }

    return res
    
}

```

## 5.测试验证
```
const obj = {a: 1, b: {c: 2}}
const newObj = cloneShallowly(obj)
newObj.b.c = 3
//改变newObj中的 b 属性，原 obj 中的 b 属性也会被改变
console.log(newObj,obj) //{a: 1, b: {c: 3}} {a: 1, b: {c: 3}}


const arr = [1, [2, 3]] 
const newArr = cloneShallowly(arr)
newArr[1][0] = 4
//改变 newArr 中的嵌套数组的值，原 arr的嵌套数组也会发生改变
console.log(newArr,arr) //[1, [4, 3]]  [1, [4, 3]] 
```